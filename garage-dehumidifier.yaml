esphome:
  name: garage-dehumidifier
  friendly_name: garage-dehumidifier

globals:
  - id: sensor_max_distance
    type: float
    initial_value: '0.168'
  - id: sensor_min_distance
    type: float
    initial_value: '0.010'

# https://community.home-assistant.io/t/esp32-s3-devkitc-1-n16r8-using-psram-howto/652601/8
psram:
  mode: octal
  speed: 80MHz

esp32:
  board: seeed_xiao_esp32s3
  framework:
    type: esp-idf

logger:
#  level: VERY_VERBOSE

api:
  encryption:
    key: !secret api_encryption_key

ota:
  - platform: esphome
    password: !secret ota_password

wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password
  power_save_mode: none
  # esp32 needs the output_power setting, see https://github.com/espressif/arduino-esp32/issues/2144#issuecomment-2028949116
  output_power: 8.5dB

web_server:
  port: 80

prometheus:

number:
  - platform: template
    id: tank_low_threshold
    name: "Tank low threshold (%)"
    optimistic: true
    min_value: 0
    max_value: 30
    step: 0.5
    initial_value: 5
  - platform: template
    id: tank_high_threshold
    name: "Tank high threshold (%)"
    optimistic: true
    min_value: 30
    max_value: 100
    step: 0.5
    initial_value: 95

status_led:
  pin:
    number: GPIO21  #LED_BUILTIN
    inverted: true

external_components:
  - source:
      type: local
      path: components

# JSN_SR04T
uart:
  id: uart_bus
  tx_pin: GPIO9  # gpio9=yellow
  rx_pin: GPIO8  # gpio8=white
  baud_rate: 9600
  stop_bits: 1

# DS18B20
one_wire:
  - platform: gpio
    pin: GPIO6
    id: bus1

sensor:
  - platform: jsn_sr04t
    id: water_pct
    name: "Water Tank Percentage"
    unit_of_measurement: "%"
    icon: "mdi:water-percent"
    accuracy_decimals: 1
#    update_interval: 30s (not working... use throttle filter)
    filters:
      - throttle: 15s
      - lambda: |-
          // Convert distance to percentage: 0.010m = 100%, 0.168m = 0%
          if (isnan(x)) return NAN;
          
          // Clamp distance to valid range
          if (x <= id(sensor_min_distance)) return 100.0;
          if (x >= id(sensor_max_distance)) return 0.0;
          
          // Linear interpolation: percentage = 100 * (max_distance - distance) / (max_distance - min_distance)
          float percentage = 100.0 * (id(sensor_max_distance) - x) / (id(sensor_max_distance) - id(sensor_min_distance));
          return percentage;
  - platform: dallas_temp
    one_wire_id: bus1
    name: "Outlet temperature"
    accuracy_decimals: 2
    filters:
      - round: 2
#      - sliding_window_moving_average:
#          window_size: 10
#          send_every: 10
#          send_first_at: 1
    update_interval: 60s

binary_sensor:
  - platform: template
    id: low_tank_sustained
    name: "Low tank (sustained)"
    device_class: problem
    lambda: |-
      return !isnan(id(water_pct).state) && id(water_pct).state <= id(tank_low_threshold).state;
    filters:
      - delayed_on: 45s   # must stay low for 45s to trip
      - delayed_off: 20s  # adds a little hysteresis before clearing
    # Turn pump off if low level is sustained while pump is ON
    on_press:
      - if:
          condition:
            switch.is_on: pump
          then:
            - logger.log: "Dry-run: tank low, turning pump OFF"
            - switch.turn_off: pump
            - homeassistant.service:
                service: persistent_notification.create
                data:
                  title: "Pump dry-run protection tripped"
                  message: !lambda |-
                    char buf[96];
                    snprintf(buf, sizeof(buf),
                             "Pump turned off due to low water level (â‰¤%.1f%%).",
                             (double) id(tank_low_threshold).state);
                    return std::string(buf);
  - platform: template
    id: high_tank_sustained
    name: "High tank (sustained)"
    device_class: problem
    lambda: |-
      return !isnan(id(water_pct).state) && id(water_pct).state >= id(tank_high_threshold).state;
    filters:
      - delayed_on: 45s   # must stay low for 45s to trip
      - delayed_off: 20s  # adds a little hysteresis before clearing
    # Turn pump on if high level is sustained while pump is OFF
    on_press:
      - if:
          condition:
            switch.is_off: pump
          then:
            - logger.log: "Tank full, turning pump ON"
            - switch.turn_on: pump

switch:
  - platform: gpio
    id: pump
    name: "Pump"
    icon: "mdi:water-pump"
    pin: GPIO7
    on_turn_on:
      - script.execute: pump_guard_timer
    on_turn_off:
      - switch.turn_off: heater
  - platform: gpio
    id: heater
    name: "Heater"
    icon: "mdi:heat-wave"
    pin: GPIO5

script:
  - id: pump_guard_timer
    mode: restart
    then:
      - delay: 2min
      - if:
          condition:
            and:
              - switch.is_on: pump
              - lambda: |-
                  return !isnan(id(water_pct).state) &&
                         id(water_pct).state <= id(tank_low_threshold).state;
          then:
            - logger.log: "Dry-run timer: still low after 2 min, turning OFF"
            - switch.turn_off: pump
